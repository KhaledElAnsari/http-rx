import { parse } from 'acorn';
import MagicString from 'magic-string';
import { decode } from 'sourcemap-codec';

var keys = {
	Program: [ 'body' ],
	Literal: []
};

var UNKNOWN = {};
var TRUTHY = {};
var FALSY = {};

var Node = function Node ( raw, parent ) {
	raw.parent = parent;
	raw.program = parent.program || parent;
	raw.depth = parent.depth + 1;
	raw.keys = keys[ raw.type ];
	raw.indentation = undefined;

	for ( var i = 0, list = keys[ raw.type ]; i < list.length; i += 1 ) {
		var key = list[i];

		wrap( raw[ key ], raw );
	}

	raw.program.magicString.addSourcemapLocation( raw.start );
	raw.program.magicString.addSourcemapLocation( raw.end );
};

Node.prototype.ancestor = function ancestor ( level ) {
	var node = this;
	while ( level-- ) {
		node = node.parent;
		if ( !node ) { return null; }
	}

	return node;
};

Node.prototype.contains = function contains ( node ) {
		var this$1 = this;

	while ( node ) {
		if ( node === this$1 ) { return true; }
		node = node.parent;
	}

	return false;
};

Node.prototype.findLexicalBoundary = function findLexicalBoundary () {
	return this.parent.findLexicalBoundary();
};

Node.prototype.findNearest = function findNearest ( type ) {
	if ( typeof type === 'string' ) { type = new RegExp( ("^" + type + "$") ); }
	if ( type.test( this.type ) ) { return this; }
	return this.parent.findNearest( type );
};

Node.prototype.findScope = function findScope ( functionScope ) {
	return this.parent.findScope( functionScope );
};

Node.prototype.getIndentation = function getIndentation () {
	var lastLine = /\n(.+)$/.exec( this.program.magicString.original.slice( 0, this.start ) );
	return lastLine ? /^[ \t]*/.exec( lastLine[1] )[0] : '';
};

Node.prototype.getLeftHandSide = function getLeftHandSide () {
	return this;
};

Node.prototype.getPrecedence = function getPrecedence () {
	return 0;
};

Node.prototype.getRightHandSide = function getRightHandSide () {
	return this;
};

Node.prototype.getValue = function getValue () {
	return UNKNOWN;
};

Node.prototype.initialise = function initialise () {
		var this$1 = this;

	for ( var i$1 = 0, list = this$1.keys; i$1 < list.length; i$1 += 1 ) {
		var key = list[i$1];

			var value = this$1[ key ];

		if ( value ) {
			if ( 'length' in value ) {
				var i = value.length;
				while ( i-- ) {
					if ( value[i] ) { value[i].initialise(); }
				}
			} else {
				value.initialise();
			}
		}
	}
};

Node.prototype.findVarDeclarations = function findVarDeclarations ( varsToHoist ) {
		var this$1 = this;

	for ( var i$1 = 0, list = this$1.keys; i$1 < list.length; i$1 += 1 ) {
		var key = list[i$1];

			var value = this$1[ key ];

		if ( value ) {
			if ( 'length' in value ) {
				var i = value.length;
				while ( i-- ) {
					if ( value[i] ) { value[i].findVarDeclarations( varsToHoist ); }
				}
			} else {
				value.findVarDeclarations( varsToHoist );
			}
		}
	}
};

Node.prototype.minify = function minify ( code ) {
		var this$1 = this;

	for ( var i$1 = 0, list = this$1.keys; i$1 < list.length; i$1 += 1 ) {
		var key = list[i$1];

			var value = this$1[ key ];

		if ( value ) {
			if ( 'length' in value ) {
				var i = value.length;
				while ( i-- ) {
					if ( value[i] ) { value[i].minify( code ); }
				}
			} else {
				value.minify( code );
			}
		}
	}
};

Node.prototype.preventsCollapsedReturns = function preventsCollapsedReturns ( returnStatements ) {
	if ( this.type === 'ExpressionStatement' ) { return false; }
	if ( this.type === 'ReturnStatement' ) { return returnStatements.push( this ), false; }
	if ( this.type === 'IfStatement' ) { return !this.preventsCollapsedReturns( returnStatements ); }
	return true;
};

Node.prototype.source = function source () {
	return this.program.magicString.original.slice( this.start, this.end );
};

Node.prototype.toString = function toString () {
	return this.program.magicString.slice( this.start, this.end );
};

var ArrayExpression = (function (Node$$1) {
	function ArrayExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ArrayExpression.__proto__ = Node$$1;
	ArrayExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ArrayExpression.prototype.constructor = ArrayExpression;

	ArrayExpression.prototype.getValue = function getValue () {
		var this$1 = this;

		var values = new Array( this.elements.length );

		for ( var i = 0; i < this.elements.length; i += 1 ) {
			var element = this$1.elements[i];

			if ( element ) {
				var value = element.getValue();
				if ( value === UNKNOWN || value === TRUTHY || value === FALSY ) { return TRUTHY; }

				values[i] = value;
			}
		}

		return values;
	};

	ArrayExpression.prototype.minify = function minify ( code ) {
		var this$1 = this;

		var c = this.start;

		if ( this.elements.length ) {
			var insert = '[';
			this.elements.forEach( function ( element, i ) {
				if ( !element ) {
					insert += i === this$1.elements.length - 1 ? ',]' : ',';
					return;
				}

				if ( element.start > c + 1 ) { code.overwrite( c, element.start, insert ); }
				c = element.end;

				insert = i === this$1.elements.length - 1 ? ']' : ',';
			});

			if ( this.end > insert.length ) { code.overwrite( c, this.end, insert ); }
		}

		else {
			if ( this.end > c + 2 ) { code.overwrite( c, this.end, '[]' ); }
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return ArrayExpression;
}(Node));

var ArrowFunctionExpression = (function (Node$$1) {
	function ArrowFunctionExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ArrowFunctionExpression.__proto__ = Node$$1;
	ArrowFunctionExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ArrowFunctionExpression.prototype.constructor = ArrowFunctionExpression;

	ArrowFunctionExpression.prototype.findScope = function findScope () {
		return this.body.scope;
	};

	ArrowFunctionExpression.prototype.initialise = function initialise () {
		this.body.createScope( this.parent.findScope( false ) );
		Node$$1.prototype.initialise.call(this);
	};

	ArrowFunctionExpression.prototype.findVarDeclarations = function findVarDeclarations () {
		// noop
	};

	ArrowFunctionExpression.prototype.minify = function minify ( code ) {
		var c = this.start;
		if ( this.async ) { c += 5; }

		if ( this.params.length === 0 ) {
			if ( this.body.start > c + 4 ) {
				code.overwrite( c, this.body.start, '()=>' );
			}
		}

		else if ( this.params.length === 1 ) {
			this.params[0].minify( code );

			if ( this.params[0].type === 'Identifier' ) {
				// remove parens
				if ( this.async ) {
					code.overwrite( c, this.params[0].start, ' ' );
				} else {
					code.remove( c, this.params[0].start );
				}

				if ( this.body.start > this.params[0].end + 2 ) {
					code.overwrite( this.params[0].end, this.body.start, '=>' );
				}
			} else {
				if ( this.params[0].start > c + 1 ) {
					code.remove( c + 1, this.params[0].start );
				}

				if ( this.body.start > this.params[0].end + 3 ) {
					code.overwrite( this.params[0].end, this.body.start, ')=>' );
				}
			}
		}

		else {
			this.params.forEach( function ( param, i ) {
				param.minify( code );
				if ( param.start > c + 1 ) { code.overwrite( c, param.start, i ? ',' : '(' ); }
				c = param.end;
			});

			if ( this.body.start > c + 3 ) {
				code.overwrite( c, this.body.start, ')=>' );
			}
		}

		this.body.minify( code );
	};

	return ArrowFunctionExpression;
}(Node));

function locate ( source, index ) {
	var lines = source.split( '\n' );
	var len = lines.length;

	var lineStart = 0;
	var i;

	for ( i = 0; i < len; i += 1 ) {
		var line = lines[i];
		var lineEnd =  lineStart + line.length + 1; // +1 for newline

		if ( lineEnd > index ) {
			return { line: i + 1, column: index - lineStart, char: i };
		}

		lineStart = lineEnd;
	}

	throw new Error( 'Could not determine location of character' );
}

function pad ( num, len ) {
	var result = String( num );
	return result + repeat( ' ', len - result.length );
}

function repeat ( str, times ) {
	var result = '';
	while ( times-- ) { result += str; }
	return result;
}

function getSnippet ( source, loc, length ) {
	if ( length === void 0 ) length = 1;

	var first = Math.max( loc.line - 5, 0 );
	var last = loc.line;

	var numDigits = String( last ).length;

	var lines = source.split( '\n' ).slice( first, last );

	var lastLine = lines[ lines.length - 1 ];
	var offset = lastLine.slice( 0, loc.column ).replace( /\t/g, '  ' ).length;

	var snippet = lines
		.map( function ( line, i ) { return ((pad( i + first + 1, numDigits )) + " : " + (line.replace( /\t/g, '  '))); } )
		.join( '\n' );

	snippet += '\n' + repeat( ' ', numDigits + 3 + offset ) + repeat( '^', length );

	return snippet;
}

var CompileError = (function (Error) {
	function CompileError ( node, message ) {
		Error.call(this);

		var source = node.program.magicString.original;
		var loc = locate( source, node.start );

		this.name = 'CompileError';
		this.message = message + " (" + (loc.line) + ":" + (loc.column) + ")";

		this.stack = new Error().stack.replace( new RegExp( (".+new " + (this.name) + ".+\\n"), 'm' ), '' );

		this.loc = loc;
		this.snippet = getSnippet( source, loc, node.end - node.start );
	}

	if ( Error ) CompileError.__proto__ = Error;
	CompileError.prototype = Object.create( Error && Error.prototype );
	CompileError.prototype.constructor = CompileError;

	return CompileError;
}(Error));

var commutative = {};
// we exclude + because it's not commutative when it's
// operating on strings
for ( var i = 0, list = '*&^|'; i < list.length; i += 1 ) {
	var operator = list[i];

	commutative[ operator ] = true;
}

var AssignmentExpression = (function (Node$$1) {
	function AssignmentExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) AssignmentExpression.__proto__ = Node$$1;
	AssignmentExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	AssignmentExpression.prototype.constructor = AssignmentExpression;

	AssignmentExpression.prototype.getLeftHandSide = function getLeftHandSide () {
		return this.left.getLeftHandSide();
	};

	AssignmentExpression.prototype.getPrecedence = function getPrecedence () {
		return 3;
	};

	AssignmentExpression.prototype.initialise = function initialise () {
		if ( this.left.type === 'Identifier' ) {
			var declaration = this.findScope( false ).findDeclaration( this.left.name );
			if ( declaration && declaration.kind === 'const' ) {
				throw new CompileError( this.left, ((this.left.name) + " is read-only") );
			}
		}

		Node$$1.prototype.initialise.call(this);
	};

	AssignmentExpression.prototype.minify = function minify ( code ) {
		if ( this.right.start > this.left.end + this.operator.length ) {
			code.overwrite( this.left.end, this.right.start, this.operator );
		}

		// special case – `a = a + 1` -> `a += 1`
		if ( this.operator === '=' && this.left.type === 'Identifier' && this.right.type === 'BinaryExpression' ) {
			if ( this.right.left.type === 'Identifier' && ( this.right.left.name === this.left.name ) ) {
				code.appendLeft( this.left.end, this.right.operator );
				code.remove( this.right.start, this.right.right.start );

				this.right.right.minify( code );
				return;
			}

			// addition and multiplication
			if ( commutative[ this.right.operator ] && this.right.right.type === 'Identifier' && ( this.right.right.name === this.left.name ) ) {
				code.appendLeft( this.left.end, this.right.operator );
				code.remove( this.right.left.end, this.right.end );

				this.right.left.minify( code );
				return;
			}
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return AssignmentExpression;
}(Node));

function stringify ( value ) {
	if ( typeof value === 'function' ) { return null; }
	if ( typeof value === 'object' ) { return null; }

	if ( value !== value ) { return 'NaN'; }
	if ( value === true ) { return '!0'; }
	if ( value === false ) { return '!1'; }
	if ( value === undefined ) { return 'void 0'; }

	// TODO if string, determine which quotes to use
	// TODO if number, determine whether to use e notation

	if ( isNegativeZero( value ) ) { return '-0'; }
	return JSON.stringify( value )
		.replace( /\u2028/g, '\\u2028' )
		.replace( /\u2029/g, '\\u2029' );
}

function isNegativeZero ( num ) {
	return num === 0 && ( 1 / num < 0 );
}

var calculators = {
	'**' : function ( a, b ) { return Math.power( a, b ); },
	'*'  : function ( a, b ) { return a * b; },
	'/'  : function ( a, b ) { return a / b; },
	'%'  : function ( a, b ) { return a % b; },
	'+'  : function ( a, b ) { return a + b; },
	'-'  : function ( a, b ) { return a - b; },
	'<<' : function ( a, b ) { return a << b; },
	'>>' : function ( a, b ) { return a >> b; },
	'>>>': function ( a, b ) { return a >>> b; },
	'<'  : function ( a, b ) { return a < b; },
	'<=' : function ( a, b ) { return a <= b; },
	'>'  : function ( a, b ) { return a > b; },
	'>=' : function ( a, b ) { return a >= b; },
	'==' : function ( a, b ) { return a == b; },
	'!=' : function ( a, b ) { return a != b; },
	'===': function ( a, b ) { return a === b; },
	'!==': function ( a, b ) { return a !== b; },
	'&'  : function ( a, b ) { return a & b; },
	'^'  : function ( a, b ) { return a ^ b; },
	'|'  : function ( a, b ) { return a | b; },
	in   : function ( a, b ) { return a in b; },
	instanceof: function ( a, b ) { return a instanceof b; }
};

var binaryExpressionPrecedence = {};
[
	[  7, '|' ],
	[  8, '^' ],
	[  9, '&' ],
	[ 10, '!== === != ==' ],
	[ 11, 'instanceof in >= > <= <' ],
	[ 12, '>>> >> <<' ],
	[ 13, '- +' ],
	[ 14, '% / * **' ]
].forEach( function (ref) {
	var precedence = ref[0];
	var operators = ref[1];

	operators.split( ' ' ).forEach( function (operator) { return binaryExpressionPrecedence[ operator ] = precedence; } );
});

var BinaryExpression = (function (Node$$1) {
	function BinaryExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) BinaryExpression.__proto__ = Node$$1;
	BinaryExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	BinaryExpression.prototype.constructor = BinaryExpression;

	BinaryExpression.prototype.getLeftHandSide = function getLeftHandSide () {
		return this.left.getLeftHandSide();
	};

	BinaryExpression.prototype.getPrecedence = function getPrecedence () {
		var left = this.left.getValue();
		var right = this.right.getValue();

		if ( left === UNKNOWN || right === UNKNOWN ) { return binaryExpressionPrecedence[ this.operator ]; }

		return 20; // will be replaced by a literal
	};

	BinaryExpression.prototype.getValue = function getValue () {
		var left = this.left.getValue();
		var right = this.right.getValue();

		if ( left === UNKNOWN || right === UNKNOWN ) { return UNKNOWN; }

		return calculators[ this.operator ]( left, right );
	};

	BinaryExpression.prototype.minify = function minify ( code ) {
		var value = this.getValue();

		if ( value !== UNKNOWN ) {
			code.overwrite( this.start, this.end, stringify( value ) );
		}

		else {
			var operator = this.operator;

			if ( code.original[ this.right.getLeftHandSide().start ] === operator ) {
				// prevent e.g. `1 - --t` becoming 1---t
				operator = operator + " ";
			} else if ( /\w/.test( this.operator ) ) {
				// `foo in bar`, not `fooinbar`
				operator = " " + operator + " ";
			}

			if ( this.right.start > this.left.end + operator.length ) {
				code.overwrite( this.left.end, this.right.start, operator );
			}

			Node$$1.prototype.minify.call( this, code );
		}
	};

	return BinaryExpression;
}(Node));

var safeFunctions = [
	Array.prototype.concat,

	String.fromCharCode,
	String.fromCodePoint,

	String.prototype.charAt,
	String.prototype.charCodeAt,
	String.prototype.codePointAt,
	String.prototype.concat, // WARNING! https://github.com/jquery/jquery/pull/473
	String.prototype.endsWith,
	String.prototype.includes,
	String.prototype.indexOf,
	String.prototype.lastIndexOf,
	String.prototype.slice,
	String.prototype.startsWith,
	String.prototype.substr,
	String.prototype.substring,
	String.prototype.toLowerCase,
	String.prototype.toString,
	String.prototype.toUpperCase,
	String.prototype.trim,
	String.prototype.trimLeft,
	String.prototype.trimRight,
	String.prototype.valueOf

	// TODO others...
];

var CallExpression = (function (Node$$1) {
	function CallExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) CallExpression.__proto__ = Node$$1;
	CallExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	CallExpression.prototype.constructor = CallExpression;

	CallExpression.prototype.getPrecedence = function getPrecedence () {
		return 17;
	};

	CallExpression.prototype.getValue = function getValue () {
		var this$1 = this;

		var calleeValue = this.callee.getValue();

		if ( typeof calleeValue !== 'function' ) { return UNKNOWN; }
		if ( !~safeFunctions.indexOf( calleeValue ) ) { return UNKNOWN; }

		var contextValue = this.callee.type === 'MemberExpression' ?
			this.callee.object.getValue() :
			null;

		var argumentValues = new Array( this.arguments.length );
		for ( var i = 0; i < this.arguments.length; i += 1 ) {
			var argument = this$1.arguments[i];

			if ( argument ) {
				var value = argument.getValue();
				if ( value === UNKNOWN || value === TRUTHY || value === FALSY ) { return UNKNOWN; }

				argumentValues[i] = value;
			}
		}

		return calleeValue.apply( contextValue, argumentValues );
	};

	CallExpression.prototype.initialise = function initialise () {
		Node$$1.prototype.initialise.call(this);
	};

	CallExpression.prototype.minify = function minify ( code ) {
		var this$1 = this;

		var value = this.getValue();

		if ( value !== UNKNOWN ) {
			var str = stringify( value );

			if ( str !== null ) {
				code.overwrite( this.start, this.end, str );
				return;
			}
		}

		if ( this.arguments.length ) {
			var lastNode = this.callee;

			for ( var i = 0; i < this.arguments.length; i += 1 ) {
				var argument = this$1.arguments[i];

				if ( argument.start > lastNode.end + 1 ) { code.overwrite( lastNode.end, argument.start, i ? ',' : '(' ); }
				lastNode = argument;
			}

			if ( this.end > lastNode.end + 1 ) { code.overwrite( lastNode.end, this.end, ')' ); }
		}

		else if ( this.end > this.callee.end + 2 ) {
			code.overwrite( this.callee.end, this.end, '()' );
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return CallExpression;
}(Node));

var CatchClause = (function (Node$$1) {
	function CatchClause () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) CatchClause.__proto__ = Node$$1;
	CatchClause.prototype = Object.create( Node$$1 && Node$$1.prototype );
	CatchClause.prototype.constructor = CatchClause;

	CatchClause.prototype.minify = function minify ( code ) {
		if ( this.param.start > this.start + 6 ) {
			code.overwrite( this.start + 5, this.param.start, '(' );
		}

		if ( this.body.start > this.param.end + 1 ) {
			code.overwrite( this.param.end, this.body.start, ')' );
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return CatchClause;
}(Node));

function minifyPropertyKey ( code, property, isObject ) {
	if ( property.shorthand ) { return; }

	var separator = ( isObject && !property.method ) ? ':' : '';

	if ( property.value.async || property.value.generator || property.computed ) {
		var prefix = ( property.value.async ? ( property.computed ? 'async' : 'async ' ) : property.value.generator ? '*' : '' ) + ( property.computed ? '[' : '' );
		if ( property.key.start - property.start > prefix.length ) { code.overwrite( property.start, property.key.start, prefix ); }

		var suffix = ( property.computed ? ']' : '' ) + separator;
		if ( property.value.start - property.key.end > suffix.length ) { code.overwrite( property.key.end, property.value.start, suffix ); }
	}

	else if ( separator ) {
		if ( property.value.start - property.key.end > 1 ) { code.overwrite( property.key.end, property.value.start, separator ); }
	}

	else {
		code.remove( property.key.end, property.value.start );
	}
}

var ClassBody = (function (Node$$1) {
	function ClassBody () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ClassBody.__proto__ = Node$$1;
	ClassBody.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ClassBody.prototype.constructor = ClassBody;

	ClassBody.prototype.minify = function minify ( code ) {
		var this$1 = this;

		var c = this.start + 1;

		for ( var i = 0; i < this.body.length; i += 1 ) {
			var method = this$1.body[i];
			if ( method.start > c ) { code.remove( c, method.start ); }

			minifyPropertyKey( code, method, false );

			c = method.end;
		}

		if ( this.end > c + 1 ) { code.remove( c, this.end - 1 ); }

		Node$$1.prototype.minify.call( this, code );
	};

	return ClassBody;
}(Node));

var Class = (function (Node$$1) {
	function Class () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) Class.__proto__ = Node$$1;
	Class.prototype = Object.create( Node$$1 && Node$$1.prototype );
	Class.prototype.constructor = Class;

	Class.prototype.minify = function minify ( code ) {
		var c = this.superClass ? this.superClass.end : this.id ? this.id.end : this.start + 6;

		if ( this.id ) {
			if ( this.id.start > this.start + 6 ) {
				code.remove( this.start + 6, this.id.start );
			}

			if ( this.superClass ) {
				if ( this.superClass.start > this.id.end + 9 ) {
					code.overwrite( this.id.end, this.superClass.start, ' extends ' );
				}
			}
		} else if ( this.superClass ) {
			if ( this.superClass.start > this.start + 14 ) {
				code.overwrite( this.start + 6, this.superClass.start, 'extends ' );
			}
		}

		if ( this.body.start > c ) { code.remove( c, this.body.start ); }

		Node$$1.prototype.minify.call( this, code );
	};

	return Class;
}(Node));

var ClassDeclaration = (function (Class$$1) {
	function ClassDeclaration () {
		Class$$1.apply(this, arguments);
	}

	if ( Class$$1 ) ClassDeclaration.__proto__ = Class$$1;
	ClassDeclaration.prototype = Object.create( Class$$1 && Class$$1.prototype );
	ClassDeclaration.prototype.constructor = ClassDeclaration;

	ClassDeclaration.prototype.activate = function activate () {
		this.skip = false;
		Class$$1.prototype.initialise.call(this);
	};

	ClassDeclaration.prototype.initialise = function initialise () {
		this.skip = true;
		this.id.declaration = this;

		this.name = this.id.name; // TODO what is this used for?
		this.findScope( true ).addDeclaration( this.id, 'class' );
	};

	return ClassDeclaration;
}(Class));

var reserved = Object.create( null );
'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'.split( ' ' )
	.forEach( function (word) { return reserved[ word ] = true; } );

var letConst = /^(?:let|const)$/;

var validChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';

function Scope ( options ) {
	options = options || {};

	this.parent = options.parent;
	this.owner = options.owner;
	this.isBlockScope = !!options.block;

	var scope = this;
	while ( scope.isBlockScope ) { scope = scope.parent; }
	this.functionScope = scope;

	this.identifiers = [];
	this.declarations = Object.create( null );
	this.references = Object.create( null );
	this.blockScopedDeclarations = this.isBlockScope ? null : Object.create( null );
	this.aliases = Object.create( null );

	this.idCounter = [ 0 ];
}

Scope.prototype = {
	addAlias: function addAlias ( alias ) {
		this.aliases[ alias ] = true;
		if ( this.parent ) { this.parent.addAlias( alias ); }
	},

	addDeclaration: function addDeclaration ( identifier, kind ) {
		if ( kind === 'var' && this.isBlockScope ) {
			this.parent.addDeclaration( identifier, kind );
			return;
		}

		var name = identifier.name;

		var existingDeclaration = this.declarations[ name ];
		if ( existingDeclaration ) {
			if ( letConst.test( kind ) || letConst.test( existingDeclaration.kind ) ) {
				// TODO warn about double var declarations?
				throw new CompileError( identifier, (name + " is already declared") );
			}

			// special case — function expression IDs that are shadowed by
			// declarations should just be removed (TODO unless the user wishes
			// to keep function names — https://github.com/Rich-Harris/butternut/issues/17)
			if ( existingDeclaration.node.parent.type === 'FunctionExpression' ) {
				existingDeclaration.node.parent.removeId = true;
			}

			else {
				identifier.isDuplicate = true;

				if ( existingDeclaration.activated ) {
					identifier.activate();
				} else {
					existingDeclaration.duplicates.push( identifier );
				}

				return;
			}
		}

		var declaration = {
			activated: !this.parent, // TODO is this necessary?
			name: name,
			node: identifier,
			kind: kind,
			instances: [],
			duplicates: []
		};

		this.declarations[ name ] = declaration;

		if ( this.isBlockScope ) {
			if ( !this.functionScope.blockScopedDeclarations[ name ] ) { this.functionScope.blockScopedDeclarations[ name ] = []; }
			this.functionScope.blockScopedDeclarations[ name ].push( declaration );
		}

		if ( kind === 'param' ) {
			declaration.instances.push( identifier );
		}

		if ( !this.parent ) {
			identifier.activate();
		}
	},

	addReference: function addReference ( identifier ) {
		if ( this.consolidated ) {
			this.consolidateReference( identifier );
		} else {
			this.identifiers.push( identifier );
		}
	},

	consolidate: function consolidate () {
		var this$1 = this;

		for ( var i = 0; i < this.identifiers.length; i += 1 ) { // we might push to the array during consolidation, so don't cache length
			var identifier = this$1.identifiers[i];
			this$1.consolidateReference( identifier );
		}

		this.consolidated = true; // TODO understand why this is necessary... seems bad
	},

	consolidateReference: function consolidateReference ( identifier ) {
		var declaration = this.declarations[ identifier.name ];
		if ( declaration ) {
			declaration.instances.push( identifier );

			if ( !declaration.activated ) {
				declaration.activated = true;
				// const parent = declaration.node.parent;

				declaration.node.activate();
				declaration.duplicates.forEach( function (dupe) {
					dupe.activate();
				});
				// if ( declaration.kind === 'param' ) {
				// 	// TODO is there anything to do here?
				// } else if ( parent.activate ) {
				// 	parent.activate();
				// }
			}
		} else {
			this.references[ identifier.name ] = true;
			if ( this.parent ) { this.parent.addReference( identifier ); }
		}
	},

	contains: function contains ( name ) {
		return this.declarations[ name ] ||
		       ( this.parent ? this.parent.contains( name ) : false );
	},

	containsAlias: function containsAlias ( alias ) {
		return this.aliases[ alias ] || ( this.parent && this.parent.containsAlias( alias ) );
	},

	createIdentifier: function createIdentifier ( used ) {
		var this$1 = this;

		var alias;

		do {
			alias = this$1.idCounter.map( function (i) { return validChars[i]; } ).join( '' );

			var i = this$1.idCounter.length;
			while ( i-- ) {
				this$1.idCounter[i] += 1;
				if ( this$1.idCounter[i] === validChars.length ) {
					this$1.idCounter[i] = 0;

					if ( i === 0 ) { this$1.idCounter.push( 0 ); }
				} else {
					break;
				}
			}
		} while ( used[ alias ] || reserved[ alias ] );

		return alias;
	},

	findDeclaration: function findDeclaration ( name ) {
		return this.declarations[ name ] ||
		       ( this.parent && this.parent.findDeclaration( name ) );
	},

	mangle: function mangle ( code ) {
		var this$1 = this;

		if ( !this.parent ) { return; }

		var used = Object.create( null );

		Object.keys( this.references ).forEach( function (reference) {
			var declaration = this$1.parent && this$1.parent.findDeclaration( reference );
			used[ declaration ? declaration.alias : reference ] = true;
		});

		Object.keys( this.declarations ).forEach( function (name) {
			var declaration = this$1.declarations[ name ];
			declaration.alias = this$1.createIdentifier( used );

			declaration.instances.forEach( function (instance) {
				// special case — function expression IDs may be removed outright
				if ( instance.parent.type === 'FunctionExpression' && instance === instance.parent.id && instance.parent.removeId ) { return; }

				var replacement = instance.parent.type === 'Property' && instance.parent.shorthand ?
					((instance.name) + ":" + (declaration.alias)) :
					declaration.alias;

				code.overwrite( instance.start, instance.end, replacement, true );
			});
		});
	}
};

var ClassExpression = (function (Class$$1) {
	function ClassExpression () {
		Class$$1.apply(this, arguments);
	}

	if ( Class$$1 ) ClassExpression.__proto__ = Class$$1;
	ClassExpression.prototype = Object.create( Class$$1 && Class$$1.prototype );
	ClassExpression.prototype.constructor = ClassExpression;

	ClassExpression.prototype.findScope = function findScope () {
		return this.scope;
	};

	ClassExpression.prototype.initialise = function initialise () {
		this.scope = new Scope({
			block: true,
			parent: this.parent.findScope( false ),
			owner: this
		});

		if ( this.id ) {
			this.id.declaration = this;

			// function expression IDs belong to the child scope...
			this.scope.addDeclaration( this.id, 'class' );
			this.scope.addReference( this.id );
		}

		Class$$1.prototype.initialise.call(this);

		this.scope.consolidate();
	};

	ClassExpression.prototype.minify = function minify ( code ) {
		this.scope.mangle( code );
		Class$$1.prototype.minify.call( this, code );
	};

	return ClassExpression;
}(Class));

var ConditionalExpression = (function (Node$$1) {
	function ConditionalExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ConditionalExpression.__proto__ = Node$$1;
	ConditionalExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ConditionalExpression.prototype.constructor = ConditionalExpression;

	ConditionalExpression.prototype.getLeftHandSide = function getLeftHandSide () {
		var testValue = this.test.getValue();
		var node = testValue === UNKNOWN ? this.test : ( testValue && testValue !== FALSY ? this.consequent : this.alternate );

		return node.getLeftHandSide();
	};

	ConditionalExpression.prototype.getPrecedence = function getPrecedence () {
		var testValue = this.test.getValue();
		return testValue === UNKNOWN ? 4 : ( testValue && testValue !== FALSY ? this.consequent : this.alternate ).getPrecedence();
	};

	ConditionalExpression.prototype.getRightHandSide = function getRightHandSide () {
		var testValue = this.test.getValue();
		var node = testValue === UNKNOWN ? this.alternate : ( testValue && testValue !== FALSY ? this.alternate : this.consequent );

		return node.getRightHandSide();
	};

	ConditionalExpression.prototype.getValue = function getValue () {
		var testValue = this.test.getValue();
		var consequentValue = this.consequent.getValue();
		var alternateValue = this.alternate.getValue();

		if ( testValue === UNKNOWN || consequentValue === UNKNOWN || alternateValue === UNKNOWN ) { return UNKNOWN; }

		return ( testValue && testValue !== FALSY ) ? consequentValue : alternateValue;
	};

	ConditionalExpression.prototype.initialise = function initialise () {
		var testValue = this.test.getValue();

		if ( testValue === UNKNOWN ) {
			Node$$1.prototype.initialise.call(this);
		} else if ( testValue ) {
			this.consequent.initialise();
		} else {
			this.alternate.initialise();
		}
	};

	ConditionalExpression.prototype.minify = function minify ( code ) {
		var testValue = this.test.getValue();

		// TODO rewrite `!a ? b() : c()` as `a ? c() : b()`

		if ( testValue === UNKNOWN ) {
			// remove whitespace
			if ( this.consequent.start > this.test.end + 1 ) {
				code.overwrite( this.test.end, this.consequent.start, '?' );
			}

			if ( this.alternate.start > this.consequent.end + 1 ) {
				code.overwrite( this.consequent.end, this.alternate.start, ':' );
			}

			Node$$1.prototype.minify.call( this, code );
		} else if ( testValue && testValue !== FALSY ) {
			// remove test and alternate
			code.remove( this.start, this.consequent.start );
			code.remove( this.consequent.end, this.end );

			this.consequent.minify( code );
		} else {
			// remove test and consequent
			code.remove( this.start, this.alternate.start );

			this.alternate.minify( code );
		}
	};

	return ConditionalExpression;
}(Node));

var DoWhileStatement = (function (Node$$1) {
	function DoWhileStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) DoWhileStatement.__proto__ = Node$$1;
	DoWhileStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	DoWhileStatement.prototype.constructor = DoWhileStatement;

	DoWhileStatement.prototype.minify = function minify ( code ) {
		// special case
		if ( this.body.body.length === 0 || this.body.body[0].type === 'EmptyStatement' ) {
			code.overwrite( this.start + 2, this.test.start, ';while(' );
		}

		else {
			if ( this.body.synthetic ) {
				code.overwrite( this.start + 2, this.body.body[0].start, '{' );

				var c = this.body.body[ this.body.body.length - 1 ].end;
				while ( code.original[ c - 1 ] === ';' ) { c -= 1; }
				code.overwrite( c, this.test.start, '}while(' );
			} else {
				code.remove( this.start + 2, this.body.start );
				code.overwrite( this.body.end, this.test.start, 'while(' );
			}
		}

		if ( this.end > this.test.end + 1 ) {
			var c$1 = this.end;
			while ( code.original[ c$1 - 1 ] === ';' ) { c$1 -= 1; }
			code.overwrite( this.test.end, c$1, ')' );
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return DoWhileStatement;
}(Node));

var ExpressionStatement = (function (Node$$1) {
	function ExpressionStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ExpressionStatement.__proto__ = Node$$1;
	ExpressionStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ExpressionStatement.prototype.constructor = ExpressionStatement;

	ExpressionStatement.prototype.getPrecedence = function getPrecedence () {
		return this.expression.getPrecedence();
	};

	return ExpressionStatement;
}(Node));

var LoopStatement = (function (Node$$1) {
	function LoopStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) LoopStatement.__proto__ = Node$$1;
	LoopStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	LoopStatement.prototype.constructor = LoopStatement;

	LoopStatement.prototype.findScope = function findScope ( functionScope ) {
		if ( functionScope || !this.hasVariableDeclaration() ) { return this.parent.findScope( functionScope ); }

		if ( !this.body.scope ) { this.body.createScope( this.parent.findScope() ); }
		return this.body.scope;
	};

	LoopStatement.prototype.minify = function minify ( code ) {
		// special case — empty body
		if ( this.body.body.length === 0 || this.body.body[0].type === 'EmptyStatement' ) {
			code.appendLeft( this.body.start, ';' );
			code.remove( this.body.start, this.body.end );
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return LoopStatement;
}(Node));

var ForStatement = (function (LoopStatement$$1) {
	function ForStatement () {
		LoopStatement$$1.apply(this, arguments);
	}

	if ( LoopStatement$$1 ) ForStatement.__proto__ = LoopStatement$$1;
	ForStatement.prototype = Object.create( LoopStatement$$1 && LoopStatement$$1.prototype );
	ForStatement.prototype.constructor = ForStatement;

	ForStatement.prototype.getRightHandSide = function getRightHandSide () {
		return this.body.getRightHandSide();
	};

	ForStatement.prototype.hasVariableDeclaration = function hasVariableDeclaration () {
		return this.init && this.init.type === 'VariableDeclaration';
	};

	ForStatement.prototype.minify = function minify ( code, transforms ) {
		var c = this.start + 3;

		var replacement = '(';

		[ this.init, this.test, this.update ].forEach( function ( statement, i ) {
			if ( statement ) {
				if ( statement.start > c + replacement.length ) {
					code.overwrite( c, statement.start, replacement );
				}

				c = statement.end;
				replacement = '';
			}

			replacement += i === 2 ? ')' : ';';
		});

		if ( this.body.start > c + replacement.length ) {
			code.overwrite( c, this.body.start, replacement );
		}

		LoopStatement$$1.prototype.minify.call( this, code, transforms );
	};

	return ForStatement;
}(LoopStatement));

var ForInOfStatement = (function (LoopStatement$$1) {
	function ForInOfStatement () {
		LoopStatement$$1.apply(this, arguments);
	}

	if ( LoopStatement$$1 ) ForInOfStatement.__proto__ = LoopStatement$$1;
	ForInOfStatement.prototype = Object.create( LoopStatement$$1 && LoopStatement$$1.prototype );
	ForInOfStatement.prototype.constructor = ForInOfStatement;

	ForInOfStatement.prototype.getRightHandSide = function getRightHandSide () {
		return this.body.getRightHandSide();
	};

	ForInOfStatement.prototype.hasVariableDeclaration = function hasVariableDeclaration () {
		return this.left.type === 'VariableDeclaration';
	};

	ForInOfStatement.prototype.minify = function minify ( code, transforms ) {
		if ( this.left.start > this.start + 4 ) {
			code.overwrite( this.start + 3, this.left.start, '(' );
		}

		if ( this.right.start > this.left.end + 4 ) {
			code.overwrite( this.left.end, this.right.start, ' in ' );
		}

		if ( this.body.start > this.right.end + 1 ) {
			code.overwrite( this.right.end, this.body.start, ')' );
		}

		LoopStatement$$1.prototype.minify.call( this, code, transforms );
	};

	return ForInOfStatement;
}(LoopStatement));

var Function = (function (Node$$1) {
	function Function () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) Function.__proto__ = Node$$1;
	Function.prototype = Object.create( Node$$1 && Node$$1.prototype );
	Function.prototype.constructor = Function;

	Function.prototype.findVarDeclarations = function findVarDeclarations () {
		// noop
	};

	Function.prototype.minify = function minify ( code ) {
		var this$1 = this;

		var c = this.start;
		var openParams;

		if ( this.parent.type === 'MethodDefinition' || this.parent.method ) {
			// `async` or `*` are dealt with by the parent
			openParams = '(';
		}

		else {
			openParams = this.generator ? '*(' : '(';

			if ( this.async ) {
				c += 6;
				while ( code.original[c] !== 'f' ) { c += 1; }
				if ( c > this.start + 6 ) { code.remove( this.start + 6, c ); }
			}

			c += 8;

			if ( this.id && !this.removeId ) {
				c += 1;

				if ( this.id.start > c ) { code.remove( c, this.id.start ); }
				c = this.id.end;
			}
		}

		if ( this.params.length ) {
			for ( var i = 0; i < this.params.length; i += 1 ) {
				var param = this$1.params[i];

				if ( param.start > c + 1 ) { code.overwrite( c, param.start, i ? ',' : openParams ); }
				c = param.end;
			}

			if ( this.end > c + 1 ) { code.overwrite( c, this.body.start, ')' ); }
		}

		else if ( this.body.start > c + 2 ) {
			code.overwrite( c, this.body.start, (openParams + ")") );
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return Function;
}(Node));

var FunctionDeclaration = (function (Function$$1) {
	function FunctionDeclaration () {
		Function$$1.apply(this, arguments);
	}

	if ( Function$$1 ) FunctionDeclaration.__proto__ = Function$$1;
	FunctionDeclaration.prototype = Object.create( Function$$1 && Function$$1.prototype );
	FunctionDeclaration.prototype.constructor = FunctionDeclaration;

	FunctionDeclaration.prototype.activate = function activate () {
		this.skip = false;
		Function$$1.prototype.initialise.call(this);
	};

	FunctionDeclaration.prototype.initialise = function initialise () {
		var scope = this.findScope( false );
		this.body.createScope( scope );

		if ( this.id ) { // if not, it's a default export
			this.id.declaration = this;
			scope.addDeclaration( this.id, 'function' );

			this.skip = !!scope.parent; // guilty until proven innocent
		}
	};

	return FunctionDeclaration;
}(Function));

var FunctionExpression = (function (Function$$1) {
	function FunctionExpression () {
		Function$$1.apply(this, arguments);
	}

	if ( Function$$1 ) FunctionExpression.__proto__ = Function$$1;
	FunctionExpression.prototype = Object.create( Function$$1 && Function$$1.prototype );
	FunctionExpression.prototype.constructor = FunctionExpression;

	FunctionExpression.prototype.getPrecedence = function getPrecedence () {
		return 20;
	};

	FunctionExpression.prototype.initialise = function initialise () {
		this.body.createScope( this.parent.findScope( false ) );

		if ( this.id ) {
			this.id.declaration = this;

			// function expression IDs belong to the child scope...
			this.body.scope.addDeclaration( this.id, 'function' );
			this.body.scope.addReference( this.id );
		}

		Function$$1.prototype.initialise.call(this);
	};

	return FunctionExpression;
}(Function));

function isReference ( node, parent ) {
	if ( node.type === 'MemberExpression' ) {
		return !node.computed && isReference( node.object, node );
	}

	if ( node.type === 'Identifier' ) {
		// the only time we could have an identifier node without a parent is
		// if it's the entire body of a function without a block statement –
		// i.e. an arrow function expression like `a => a`
		if ( !parent ) { return true; }

		// TODO what was this for?
		//if ( /(Function|Class)Expression/.test( parent.type ) && node === parent.id ) return false;

		// TODO is this right?
		if ( parent.type === 'MemberExpression' || parent.type === 'MethodDefinition' ) {
			return parent.computed || node === parent.object;
		}

		// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
		if ( parent.type === 'Property' ) { return parent.computed || node === parent.value; }

		// disregard the `bar` in `class Foo { bar () {...} }`
		if ( parent.type === 'MethodDefinition' ) { return false; }

		// disregard the `bar` in `export { foo as bar }`
		if ( parent.type === 'ExportSpecifier' && node !== parent.local ) { return false; }

		return true;
	}
}

var Identifier = (function (Node$$1) {
	function Identifier () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) Identifier.__proto__ = Node$$1;
	Identifier.prototype = Object.create( Node$$1 && Node$$1.prototype );
	Identifier.prototype.constructor = Identifier;

	Identifier.prototype.activate = function activate () {
		if ( this.declaration && this.declaration.activate ) {
			this.declaration.activate();
		}
	};

	Identifier.prototype.getPrecedence = function getPrecedence () {
		return 20;
	};

	Identifier.prototype.initialise = function initialise () {
		// special case
		if ( ( this.parent.type === 'FunctionExpression' || this.parent.type === 'ClassExpression' ) && this === this.parent.id ) {
			return;
		}

		if ( isReference( this, this.parent ) ) {
			this.findScope( false ).addReference( this );
		}
	};

	Identifier.prototype.minify = function minify () {
		// TODO should aliasing happen here, rather than in Scope?
		// if ( this.alias ) {
		// 	const replacement = this.parent.type === 'Property' && this.parent.shorthand ?
		// 		`${this.name}:${this.alias}` :
		// 		this.alias;

		// 	code.overwrite( this.start, this.end, replacement, true );
		// }
	};

	return Identifier;
}(Node));

var invalidChars = /[a-zA-Z$_0-9/]/;

function canRewriteBlockAsSequence ( body ) {
	var i = body.length;
	while ( i-- ) {
		var child = body[i];
		if ( child.type !== 'ExpressionStatement' /*&& child.type !== 'ReturnStatement'*/ ) {
			if ( child.type !== 'IfStatement' ) { return false; }
			if ( !canRewriteIfStatementAsSequence( child ) ) { return false; }
		}
	}

	return true;
}

function canRewriteIfStatementAsSequence ( node ) {
	if ( !canRewriteBlockAsSequence( node.consequent.body ) ) { return false; }

	if ( node.alternate ) {
		if ( node.alternate.type === 'IfStatement' ) {
			return canRewriteIfStatementAsSequence( node.alternate );
		}

		if ( node.alternate.type === 'BlockStatement' ) {
			if ( !canRewriteBlockAsSequence( node.alternate.body ) ) { return false; }
			return true;
		}

		return node.alternate.type === 'ExpressionStatement';
	}

	return true;
}

function isVarDeclaration ( node ) {
	return node.kind === 'var';
}

// TODO this whole thing is kinda messy... refactor it

var IfStatement = (function (Node$$1) {
	function IfStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) IfStatement.__proto__ = Node$$1;
	IfStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	IfStatement.prototype.constructor = IfStatement;

	IfStatement.prototype.getRightHandSide = function getRightHandSide () {
		// TODO what if we know the test value?
		if ( this.alternate ) { return this.alternate.getRightHandSide(); }
		return this.consequent.getRightHandSide();
	};

	IfStatement.prototype.initialise = function initialise () {
		var this$1 = this;

		this.rewriteConsequentAsSequence = canRewriteBlockAsSequence( this.consequent.body );
		this.rewriteAlternateAsSequence = !this.alternate ||
			( this.alternate.type === 'ExpressionStatement' ) ||
			( this.alternate.type === 'IfStatement' && canRewriteIfStatementAsSequence( this.alternate ) ) ||
			( this.alternate.type === 'BlockStatement' ) && canRewriteBlockAsSequence( this.alternate.body );

		this.rewriteAsSequence = this.rewriteConsequentAsSequence && this.rewriteAlternateAsSequence;

		var testValue = this.test.getValue();

		if ( testValue === UNKNOWN ) {
			// initialise everything
			this.test.initialise();
			this.consequent.initialise();
			if ( this.alternate ) { this.alternate.initialise(); }

			if ( this.rewriteConsequentAsSequence || this.consequent.body.every( isVarDeclaration ) ) {
				this.consequent.removeCurlies = true;
			}

			if ( this.alternate ) {
				if ( this.rewriteAlternateAsSequence || isVarDeclaration( this.alternate ) || ( this.alternate.type === 'BlockStatement' && this.alternate.body.every( isVarDeclaration ) ) ) {
					this.alternate.removeCurlies = true;
				}
			}
		}

		else if ( testValue ) { // if ( true ) {...}
			this.consequent.initialise();

			// hoist any var declarations in the alternate, so we can
			// discard the whole thing
			if ( this.alternate ) {
				var varsToHoist = {};
				this.alternate.findVarDeclarations( varsToHoist );

				// TODO do something with varsToHoist
			}

			// TODO does this apply equally to else blocks?
			if ( !this.consequent.synthetic ) {
				// if there are no let/const/class/function declarations, we can
				// remove the curlies
				var removeCurlies = true;
				var i = this.consequent.body.length;
				while ( i-- ) {
					var node = this$1.consequent.body[i];
					if ( /Declaration/.test( node.type ) && node.kind !== 'var' ) {
						removeCurlies = false;
						break;
					}
				}

				this.consequent.removeCurlies = removeCurlies;
			}
		}

		else { // if ( false ) {...}
			if ( this.alternate ) {
				this.alternate.removeCurlies = this.rewriteAlternateAsSequence;
				this.alternate.initialise();
			} else {
				this.skip = true;
			}

			var varsToHoist$1 = {};
			this.consequent.findVarDeclarations( varsToHoist$1 );

			// TODO do something with varsToHoist
		}
	};

	IfStatement.prototype.minify = function minify ( code ) {
		var testValue = this.test.getValue();

		if ( testValue !== UNKNOWN ) {
			if ( testValue ) { // if ( true ) {...}
				if ( this.alternate ) {
					// TODO handle var declarations in alternate
					code.remove( this.consequent.end, this.end );
				}

				code.remove( this.start, this.consequent.start );
				this.consequent.minify( code );
			} else { // if ( false ) {...}
				// we know there's an alternate, otherwise we wouldn't be here
				this.alternate.minify( code );
				code.remove( this.start, this.alternate.start );
			}

			return;
		}

		this.test.minify( code );

		var inverted = this.test.type === 'UnaryExpression' && this.test.operator === '!';

		// if we're rewriting as &&, test must be higher precedence than 6
		// to avoid being wrapped in parens. If ternary, 4
		var targetPrecedence = this.alternate ? 4 : inverted ? 5 : 6;

		var shouldParenthesiseTest = this.test.getPrecedence() < targetPrecedence;
		var shouldParenthesiseConsequent = this.consequent.body.length === 1 ?
			this.consequent.body[0].getPrecedence() < targetPrecedence :
			true;

		// special case – empty if block
		if ( this.consequent.body.length === 0 ) {
			var canRemoveTest = this.test.type === 'Identifier' || this.test.getValue() !== UNKNOWN; // TODO can this ever happen?

			if ( this.alternate ) {
				this.alternate.minify( code );

				if ( this.alternate.type === 'BlockStatement' && this.alternate.body.length === 0 ) {
					if ( canRemoveTest ) {
						code.remove( this.start, this.end );
						this.removed = true;
					}
				} else if ( canRewriteIfStatementAsSequence( this ) ) {
					this.alternate.joinStatements = true;

					var alternatePrecedence;
					if ( this.alternate.type === 'IfStatement' ) {
						alternatePrecedence = this.alternate.alternate ?
							4 : // will rewrite as ternary
							5;
					} else if ( this.alternate.type === 'BlockStatement' ) {
						alternatePrecedence = this.alternate.body.length === 1 ?
							this.alternate.body[0].getPrecedence() :
							0; // sequence
					} else {
						alternatePrecedence = 0; // err on side of caution
					}

					var shouldParenthesiseAlternate = alternatePrecedence < ( inverted ? 6 : 5 );
					if ( shouldParenthesiseAlternate ) {
						code.prependRight( this.alternate.start, '(' ).appendLeft( this.alternate.end, ')' );
					}

					if ( inverted ) { code.remove( this.test.start, this.test.argument.start ); }
					code.remove( this.start, this.test.start );
					code.overwrite( this.test.end, this.alternate.start, inverted ? '&&' : '||' );
				} else {
					if ( inverted ) {
						code.overwrite( this.start + 2, this.test.argument.start, '(' );
					} else {
						code.overwrite( this.start + 2, this.test.start, '(!' );
					}

					code.overwrite( this.test.end, this.alternate.start, ')' );
				}
			} else {
				// TODO is `removed` still used?
				if ( canRemoveTest ) {
					code.remove( this.start, this.end );
					this.removed = true;
				} else {
					code.remove( this.start, this.test.start );
					code.remove( this.test.end, this.consequent.end );
				}
			}

			return;
		}

		// special case - empty else block
		if ( this.alternate && this.alternate.type === 'BlockStatement' && this.alternate.body.length === 0 ) {
			code.remove( this.consequent.end, this.end );

			if ( canRewriteIfStatementAsSequence( this ) ) {
				this.consequent.joinStatements = true;

				code.overwrite( this.start, ( inverted ? this.test.argument.start : this.test.start ), shouldParenthesiseTest ? '(' : '' );

				var replacement = shouldParenthesiseTest ? ')' : '';
				replacement += inverted ? '||' : '&&';
				if ( shouldParenthesiseConsequent ) { replacement += '('; }

				code.overwrite( this.test.end, this.consequent.start, replacement );

				if ( shouldParenthesiseConsequent ) { code.appendRight( this.consequent.end, ')' ); }
			} else {
				if ( this.test.start > this.start + 3 ) { code.overwrite( this.start, this.test.start, 'if(' ); }

				if ( this.consequent.start > this.test.end + 1 ) { code.overwrite( this.test.end, this.consequent.start, ')' ); }
				if ( this.end > this.consequent.end + 1 ) { code.remove( this.consequent.end, this.end - 1 ); }
			}

			// don't minify alternate
			this.consequent.minify( code );
			return;
		}

		this.consequent.minify( code );
		if ( this.alternate ) { this.alternate.minify( code ); }

		if ( canRewriteIfStatementAsSequence( this ) ) {
			this.consequent.joinStatements = true;

			if ( inverted ) { code.remove( this.test.start, this.test.start + 1 ); }

			if ( this.alternate ) {
				this.rewriteAsTernaryExpression( code, inverted, shouldParenthesiseTest, shouldParenthesiseConsequent );
			} else {
				this.rewriteAsLogicalExpression( code, inverted, shouldParenthesiseTest, shouldParenthesiseConsequent );
			}
		}

		else {
			if ( this.test.start > this.start + 3 ) { code.overwrite( this.start + 2, this.test.start, '(' ); }
			if ( this.consequent.start > this.test.end + 1 ) { code.overwrite( this.test.end, this.consequent.start, ')' ); }

			if ( this.alternate ) {
				var lastNodeOfConsequent = this.consequent.getRightHandSide();

				var firstNodeOfAlternate = ( this.alternate.type === 'BlockStatement' && this.alternate.removeCurlies ?
					this.alternate.body[0] :
					this.alternate ).getLeftHandSide();

				var gap = ( lastNodeOfConsequent.type === 'BlockStatement' ? '' : ';' ) + 'else';
				if ( invalidChars.test( code.original[ firstNodeOfAlternate.start ] ) ) { gap += ' '; }

				var c = this.consequent.end;
				while ( code.original[ c - 1 ] === ';' ) { c -= 1; }

				code.overwrite( c, this.alternate.start, gap );
			}
		}
	};

	IfStatement.prototype.preventsCollapsedReturns = function preventsCollapsedReturns ( returnStatements ) {
		var this$1 = this;

		for ( var i = 0, list = this$1.consequent.body; i < list.length; i += 1 ) {
			var statement = list[i];

			if ( statement.skip ) { continue; }
			if ( statement.preventsCollapsedReturns( returnStatements ) ) { return true; }
		}

		if ( this.alternate ) {
			if ( this.alternate.type === 'ExpressionStatement' ) { return false; }
			if ( this.alternate.type === 'ReturnStatement' ) { return returnStatements.push( this.alternate ), false; }
			if ( this.alternate.type === 'IfStatement' ) { return this.alternate.preventsCollapsedReturns( returnStatements ); }

			if ( this.alternate.type === 'BlockStatement' ) {
				for ( var i$1 = 0, list$1 = this$1.alternate.body; i$1 < list$1.length; i$1 += 1 ) {
					var statement$1 = list$1[i$1];

					if ( statement$1.skip ) { continue; }
					if ( statement$1.preventsCollapsedReturns( returnStatements ) ) { return true; }
				}
			}
		}
	};

	IfStatement.prototype.rewriteAsLogicalExpression = function rewriteAsLogicalExpression ( code, inverted, shouldParenthesiseTest, shouldParenthesiseConsequent ) {
		this.rewriteAsSequence = true;

		code.overwrite( this.start, this.test.start, shouldParenthesiseTest ? '(' : '' );

		var replacement = ( shouldParenthesiseTest ? ')' : '' ) + ( inverted ? '||' : '&&' ) + ( shouldParenthesiseConsequent ? '(' : '' );
		code.overwrite( this.test.end, this.consequent.start, replacement );

		if ( shouldParenthesiseConsequent ) {
			var c = this.consequent.end;
			while ( code.original[ c - 1 ] === ';' ) { c -= 1; }
			code.appendLeft( c, ')' );
		}
	};

	IfStatement.prototype.rewriteAsTernaryExpression = function rewriteAsTernaryExpression ( code, inverted, shouldParenthesiseTest, shouldParenthesiseConsequent ) {
		this.rewriteAsSequence = true;

		this.alternate.joinStatements = true;

		var shouldParenthesiseAlternate = false;
		if ( this.alternate.type === 'BlockStatement' ) {
			if ( this.alternate.body.length > 1 ) {
				shouldParenthesiseAlternate = true;
			} else if ( this.alternate.body[0].type !== 'IfStatement' ) {
				shouldParenthesiseAlternate = this.alternate.body[0].getPrecedence() < 4;
			}
		}
		// const shouldParenthesiseAlternate = this.alternate.type === 'BlockStatement' ?
		// 	( this.alternate.body.length === 1 ? getPrecedence( this.alternate.body[0] ) < 4 : true ) :
		// 	false; // TODO <-- is this right? Ternaries are r-to-l, so... maybe?

		code.overwrite( this.start, this.test.start, shouldParenthesiseTest ? '(' : '' );

		var replacement = shouldParenthesiseTest ? ')?' : '?';
		if ( inverted && shouldParenthesiseAlternate ) { replacement += '('; }
		if ( !inverted && shouldParenthesiseConsequent ) { replacement += '('; }

		code.overwrite( this.test.end, this.consequent.start, replacement );

		var consequentEnd = this.consequent.end;
		while ( code.original[ consequentEnd - 1 ] === ';' ) { consequentEnd -= 1; }

		var alternateEnd = this.alternate.end;
		while ( code.original[ alternateEnd - 1 ] === ';' ) { alternateEnd -= 1; }

		code.remove( consequentEnd, this.alternate.start );

		if ( inverted ) {
			var alternateEnd$1 = this.alternate.end;
			while ( code.original[ alternateEnd$1 - 1 ] === ';' ) { alternateEnd$1 -= 1; }

			var consequentEnd$1 = this.consequent.end;
			while ( code.original[ consequentEnd$1 - 1 ] === ';' ) { consequentEnd$1 -= 1; }

			code.move( this.alternate.start, alternateEnd$1, this.consequent.start );
			code.move( this.consequent.start, consequentEnd$1, alternateEnd$1 );

			var replacement$1 = shouldParenthesiseAlternate ? '):' : ':';
			if ( shouldParenthesiseConsequent ) { replacement$1 += '('; }

			code.prependRight( this.consequent.start, replacement$1 );

			if ( shouldParenthesiseConsequent ) { code.appendLeft( consequentEnd$1, ')' ); }
		} else {
			var replacement$2 = shouldParenthesiseConsequent ? '):' : ':';
			if ( shouldParenthesiseAlternate ) { replacement$2 += '('; }

			code.appendLeft( this.consequent.end, replacement$2 );

			var c = this.alternate.end;
			while ( code.original[ c - 1 ] === ';' ) { c -= 1; }
			if ( shouldParenthesiseAlternate ) { code.appendLeft( c, ')' ); }
		}
	};

	return IfStatement;
}(Node));

var ImportDefaultSpecifier = (function (Node$$1) {
	function ImportDefaultSpecifier () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ImportDefaultSpecifier.__proto__ = Node$$1;
	ImportDefaultSpecifier.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ImportDefaultSpecifier.prototype.constructor = ImportDefaultSpecifier;

	ImportDefaultSpecifier.prototype.initialise = function initialise () {
		this.local.declaration = this;

		this.findScope( true ).addDeclaration( this.local, 'import' );
		Node$$1.prototype.initialise.call(this);
	};

	return ImportDefaultSpecifier;
}(Node));

var ImportSpecifier = (function (Node$$1) {
	function ImportSpecifier () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ImportSpecifier.__proto__ = Node$$1;
	ImportSpecifier.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ImportSpecifier.prototype.constructor = ImportSpecifier;

	ImportSpecifier.prototype.initialise = function initialise () {
		this.local.declaration = this;

		this.findScope( true ).addDeclaration( this.local, 'import' );
		Node$$1.prototype.initialise.call(this);
	};

	return ImportSpecifier;
}(Node));

var Literal = (function (Node$$1) {
	function Literal () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) Literal.__proto__ = Node$$1;
	Literal.prototype = Object.create( Node$$1 && Node$$1.prototype );
	Literal.prototype.constructor = Literal;

	Literal.prototype.getPrecedence = function getPrecedence () {
		return 20;
	};

	Literal.prototype.getValue = function getValue () {
		return this.value;
	};

	Literal.prototype.minify = function minify ( code ) {
		if ( this.value === true ) {
			code.overwrite( this.start, this.end, '!0' );
		} else if ( this.value === false ) {
			code.overwrite( this.start, this.end, '!1' );
		}
	};

	return Literal;
}(Node));

var LogicalExpression = (function (Node$$1) {
	function LogicalExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) LogicalExpression.__proto__ = Node$$1;
	LogicalExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	LogicalExpression.prototype.constructor = LogicalExpression;

	LogicalExpression.prototype.getLeftHandSide = function getLeftHandSide () {
		return this.left.getLeftHandSide();
	};

	LogicalExpression.prototype.getPrecedence = function getPrecedence () {
		var leftValue = this.left.getValue();
		var rightValue = this.right.getValue();

		if ( leftValue === UNKNOWN || rightValue === UNKNOWN ) { return this.operator === '&&' ? 6 : 5; }

		return 20; // will be replaced by a literal
	};

	LogicalExpression.prototype.getValue = function getValue () {
		var leftValue = this.left.getValue();
		var rightValue = this.right.getValue();

		if ( leftValue === UNKNOWN || rightValue === UNKNOWN ) { return UNKNOWN; }

		if ( this.operator === '&&' ) {
			if ( leftValue && leftValue !== FALSY ) { return rightValue; }
		} else {
			if ( leftValue && leftValue !== FALSY ) { return leftValue; }
			return rightValue;
		}
	};

	LogicalExpression.prototype.minify = function minify ( code ) {
		var leftValue = this.left.getValue();

		if ( leftValue === UNKNOWN ) {
			if ( this.right.start > this.left.end + this.operator.length ) {
				code.overwrite( this.left.end, this.right.start, this.operator );
			}

			Node$$1.prototype.minify.call( this, code );
		}

		else if ( leftValue && leftValue !== FALSY ) {
			if ( this.operator === '&&' ) {
				code.remove( this.start, this.right.start );
				this.right.minify( code );
			} else {
				code.remove( this.left.start, this.end );
				this.left.minify( code );
			}
		}

		else {
			if ( this.operator === '&&' ) {
				code.remove( this.left.start, this.end );
				this.left.minify( code );
			} else {
				code.remove( this.start, this.right.start );
				this.right.minify( code );
			}
		}
	};

	return LogicalExpression;
}(Node));

function isValidIdentifier ( str ) {
	// TODO there's probably a bit more to it than this
	return !reserved[ str ] && /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test( str );
}

var MemberExpression = (function (Node$$1) {
	function MemberExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) MemberExpression.__proto__ = Node$$1;
	MemberExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	MemberExpression.prototype.constructor = MemberExpression;

	MemberExpression.prototype.getValue = function getValue () {
		var objectValue = this.object.getValue();
		if ( objectValue === UNKNOWN || objectValue === TRUTHY || objectValue === FALSY ) { return UNKNOWN; }

		if ( this.computed ) {
			var propertyValue = this.property.getValue();
			if ( propertyValue === UNKNOWN || propertyValue === TRUTHY || propertyValue === FALSY ) { return UNKNOWN; }

			return objectValue[ propertyValue ];
		}

		if ( !objectValue ) { return UNKNOWN; }

		return objectValue[ this.property.name ];
	};

	MemberExpression.prototype.getPrecedence = function getPrecedence () {
		return 18;
	};

	MemberExpression.prototype.minify = function minify ( code ) {
		var value = this.getValue();

		if ( value !== UNKNOWN ) {
			var str = stringify( value );

			if ( str !== null ) {
				code.overwrite( this.start, this.end, str );
				return;
			}
		}

		if ( this.computed ) {
			var value$1 = this.property.getValue();

			if ( String( Number( value$1 ) ) === String( value$1 ) ) {
				code.overwrite( this.object.end, this.end, ("[" + value$1 + "]") );
			}

			else if ( typeof value$1 === 'string' && isValidIdentifier( value$1 ) ) {
				code.overwrite( this.object.end, this.end, ("." + value$1) );
			}

			else {
				if ( this.property.start > this.object.end + 1 ) {
					code.overwrite( this.object.end, this.property.start, '[' );
				}

				if ( this.end > this.property.end + 1 ) {
					code.overwrite( this.property.end, this.end, ']' );
				}

				this.property.minify( code );
			}
		}

		else {
			if ( this.property.start > this.object.end + 1 ) {
				code.overwrite( this.object.end, this.property.start, '.' );
			}
		}

		this.object.minify( code );
	};

	return MemberExpression;
}(Node));

var MethodDefinition = (function (Node$$1) {
	function MethodDefinition () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) MethodDefinition.__proto__ = Node$$1;
	MethodDefinition.prototype = Object.create( Node$$1 && Node$$1.prototype );
	MethodDefinition.prototype.constructor = MethodDefinition;

	MethodDefinition.prototype.minify = function minify ( code ) {
		if ( this.computed ) {
			if ( this.key.start > this.start + 1 ) { code.remove( this.start + 1, this.key.start ); }
			if ( this.value.start > this.key.end + 1 ) { code.overwrite( this.key.end, this.value.start, ']' ); }
		}

		else {
			if ( this.value.start > this.key.end ) { code.remove( this.key.end, this.value.start ); }
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return MethodDefinition;
}(Node));

var NewExpression = (function (Node$$1) {
	function NewExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) NewExpression.__proto__ = Node$$1;
	NewExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	NewExpression.prototype.constructor = NewExpression;

	NewExpression.prototype.getPrecedence = function getPrecedence () {
		return this.end > this.callee.end ? 18 : 17;
	};

	NewExpression.prototype.minify = function minify ( code ) {
		var this$1 = this;

		if ( this.arguments.length ) {
			var lastNode = this.callee;

			for ( var i = 0; i < this.arguments.length; i += 1 ) {
				var argument = this$1.arguments[i];

				if ( argument.start > lastNode.end + 1 ) { code.overwrite( lastNode.end, argument.start, i ? ',' : '(' ); }
				lastNode = argument;
			}

			if ( this.end > lastNode.end + 1 ) { code.overwrite( lastNode.end, this.end, ')' ); }
		}

		else if ( this.end > this.callee.end + 2 ) {
			code.overwrite( this.callee.end, this.end, '()' );
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return NewExpression;
}(Node));

var ObjectExpression = (function (Node$$1) {
	function ObjectExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ObjectExpression.__proto__ = Node$$1;
	ObjectExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ObjectExpression.prototype.constructor = ObjectExpression;

	ObjectExpression.prototype.getValue = function getValue () {
		return TRUTHY;
	};

	ObjectExpression.prototype.minify = function minify ( code ) {
		var this$1 = this;

		var c = this.start;

		if ( this.properties.length ) {
			for ( var i = 0; i < this.properties.length; i += 1 ) {
				var p = this$1.properties[i];

				if ( p.start > c + 1 ) { code.overwrite( c, p.start, i ? ',' : '{' ); }

				minifyPropertyKey( code, p, true );
				c = p.end;
			}

			if ( this.end > c + 1 ) { code.remove( c, this.end - 1 ); }
		} else if ( this.end > this.start + 2 ) {
			code.overwrite( this.start, this.end, '{}' );
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return ObjectExpression;
}(Node));

var ObjectPattern = (function (Node$$1) {
	function ObjectPattern () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ObjectPattern.__proto__ = Node$$1;
	ObjectPattern.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ObjectPattern.prototype.constructor = ObjectPattern;

	ObjectPattern.prototype.minify = function minify ( code ) {
		var this$1 = this;

		var c = this.start + 1;
		for ( var i = 0; i < this.properties.length; i += 1 ) {
			// TODO remove unused properties
			var property = this$1.properties[i];
			property.minify( code );

			if ( property.start > c ) { code.overwrite( c, property.start, i ? ',' : '' ); }
			c = property.end;
		}

		code.remove( c, this.end - 1 );
	};

	return ObjectPattern;
}(Node));

function shouldRemoveParens ( expression, parent ) {
	var expressionPrecedence = expression.getPrecedence();
	var parentPrecedence = parent.getPrecedence();

	if ( expression.type === 'CallExpression' ) {
		return expression.callee.type === 'FunctionExpression'; // TODO is this right?
	}

	if ( expression.type === 'FunctionExpression' ) {
		return (
			( parent.type === 'CallExpression' && parent.parent.type === 'ExpressionStatement' ) ||
			( parent.type === 'ExpressionStatement' && parent.parent.type === 'CallExpression' )
		);
	}

	if ( parentPrecedence > expressionPrecedence ) { return false; }
	if ( expressionPrecedence > parentPrecedence ) { return true; }

	if ( expression.type === 'UnaryExpression' ) { return true; }
	if ( expression.type === 'AssignmentExpression' ) { return true; }
	if ( expression.type === 'LogicalExpression' || expression.type === 'BinaryExpression' ) {
		return ( parent.operator === '**' ? parent.right : parent.left ).contains( expression );
	}
}

var ParenthesizedExpression = (function (Node$$1) {
	function ParenthesizedExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ParenthesizedExpression.__proto__ = Node$$1;
	ParenthesizedExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ParenthesizedExpression.prototype.constructor = ParenthesizedExpression;

	ParenthesizedExpression.prototype.getLeftHandSide = function getLeftHandSide () {
		var node = this;

		while ( node.type === 'ParenthesizedExpression' ) {
			node = node.expression;
		}

		if ( shouldRemoveParens( node, this.parent ) ) { return node.getLeftHandSide(); }
		return node.parent;
	};

	ParenthesizedExpression.prototype.getValue = function getValue () {
		return this.expression.getValue();
	};

	ParenthesizedExpression.prototype.minify = function minify ( code ) {
		var this$1 = this;

		var parent = this.parent;

		// TODO we can do two remove operations — one at the start, one at the
		// end. don't need to do it on each descent

		var expression = this.expression;
		while ( expression.type === 'ParenthesizedExpression' ) {
			code.remove( this$1.start, expression.start );
			code.remove( expression.end, this$1.end );
			expression = expression.expression;
		}

		if ( shouldRemoveParens( expression, parent ) ) {
			code.remove( this.start, expression.start );
			code.remove( expression.end, this.end );
		} else {
			if ( expression.start > this.start + 1 ) { code.remove( this.start + 1, expression.start ); }
			if ( this.end > expression.end + 1 ) { code.remove( expression.end, this.end - 1 ); }
		}

		// special case (?) – IIFE
		if (
			(
				this.parent.type === 'CallExpression' &&
				this.parent.parent.type === 'ExpressionStatement' &&
				/FunctionExpression/.test( expression.type )
			) ||
			(
				this.parent.type === 'ExpressionStatement' &&
				expression.type === 'CallExpression' &&
				/FunctionExpression/.test( expression.callee.type )
			)
		) {
			code.prependRight( this.start, '!' ); // could be any unary operator – uglify uses !
		}

		expression.minify( code );
	};

	return ParenthesizedExpression;
}(Node));

var invalidChars$1 = /[a-zA-Z$_0-9/]/;

var ReturnStatement = (function (Node$$1) {
	function ReturnStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) ReturnStatement.__proto__ = Node$$1;
	ReturnStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	ReturnStatement.prototype.constructor = ReturnStatement;

	ReturnStatement.prototype.minify = function minify ( code ) {
		if ( !this.argument ) { return; }

		var expression = this.argument.getLeftHandSide();

		var needsTrailingWhitespace = invalidChars$1.test( code.original[ expression.start ] );

		if ( needsTrailingWhitespace && this.argument.start === this.start + 6 ) {
			// ensure that parenthesized expression isn't too close
			code.appendLeft( this.start + 6, ' ' );
		}

		var c = this.start + ( needsTrailingWhitespace ? 7 : 6 );
		if ( this.argument.start > c ) {
			code.remove( c, this.argument.start );
		}

		this.argument.minify( code );
	};

	return ReturnStatement;
}(Node));

var SpreadElement = (function (Node$$1) {
	function SpreadElement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) SpreadElement.__proto__ = Node$$1;
	SpreadElement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	SpreadElement.prototype.constructor = SpreadElement;

	SpreadElement.prototype.getPrecedence = function getPrecedence () {
		return 1;
	};

	return SpreadElement;
}(Node));

var SwitchCase = (function (Node$$1) {
	function SwitchCase () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) SwitchCase.__proto__ = Node$$1;
	SwitchCase.prototype = Object.create( Node$$1 && Node$$1.prototype );
	SwitchCase.prototype.constructor = SwitchCase;

	SwitchCase.prototype.minify = function minify ( code ) {
		var c;

		if ( this.test ) {
			this.test.minify( code );

			if ( this.test.start > this.start + 5 ) {
				code.remove( this.start + 5, this.test.start );
			}

			c = this.test.end;
		} else {
			// default
			c = this.start + 7;
		}

		this.consequent.forEach( function ( statement, i ) {
			statement.minify( code );

			var separator = i ? ';' : ':'; // TODO can consequents be written as sequences?

			if ( statement.start === c ) {
				code.appendLeft( c, separator );
			} else {
				if ( code.original.slice( c, statement.start ) !== separator ) {
					code.overwrite( c, statement.start, separator );
				}
			}

			c = statement.end;
			while ( code.original[ c - 1 ] === ';' ) { c -= 1; }
		});
	};

	return SwitchCase;
}(Node));

var SwitchStatement = (function (Node$$1) {
	function SwitchStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) SwitchStatement.__proto__ = Node$$1;
	SwitchStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	SwitchStatement.prototype.constructor = SwitchStatement;

	SwitchStatement.prototype.minify = function minify ( code ) {
		if ( this.discriminant.start > this.start + 7 ) {
			code.overwrite( this.start + 6, this.discriminant.start, '(' );
		}

		var c = this.discriminant.end;

		this.cases.forEach( function ( switchCase, i ) {
			if ( switchCase.start > c + ( i ? 1 : 2 ) ) {
				code.overwrite( c, switchCase.start, i ? ';' : '){' );
			}

			c = switchCase.end;
			while ( code.original[ c - 1 ] === ';' ) { c -= 1; }
		});

		if ( this.end > c + 1 ) { code.overwrite( c, this.end, '}' ); }

		Node$$1.prototype.minify.call( this, code );
	};

	return SwitchStatement;
}(Node));

var TemplateLiteral = (function (Node$$1) {
	function TemplateLiteral () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) TemplateLiteral.__proto__ = Node$$1;
	TemplateLiteral.prototype = Object.create( Node$$1 && Node$$1.prototype );
	TemplateLiteral.prototype.constructor = TemplateLiteral;

	TemplateLiteral.prototype.getValue = function getValue () {
		var this$1 = this;

		var values = new Array( this.expressions.length );
		var i;

		for ( i = 0; i < this.expressions.length; i += 1 ) {
			var expression = this$1.expressions[i];
			var value = expression.getValue();

			if ( value === UNKNOWN || value === TRUTHY || value === FALSY ) { return UNKNOWN; }

			values[i] = value;
		}

		var result = '';

		for ( i = 0; i < this.expressions.length; i += 1 ) {
			var value$1 = values[i];

			result += this$1.quasis[i].value.raw;
			result += value$1;
		}

		result += this.quasis[i].value.raw;

		return result;
	};

	TemplateLiteral.prototype.minify = function minify ( code ) {
		var this$1 = this;

		var value = this.getValue();

		if ( value !== UNKNOWN ) {
			code.overwrite( this.start, this.end, stringify( value ) );
			return;
		}

		var c = this.start;
		var i;
		for ( i = 0; i < this.expressions.length; i += 1 ) {
			var expression = this$1.expressions[i];
			var quasi = this$1.quasis[i];

			expression.minify( code );

			if ( quasi.start > c + 1 ) {
				code.remove( c, quasi.start - 1 );
			}

			if ( expression.start > quasi.end + 2 ) {
				code.remove( quasi.end + 2, expression.start );
			}

			c = expression.end;
		}

		var lastQuasi = this.quasis[i];

		if ( lastQuasi.start > c + 1 ) {
			code.remove( c, lastQuasi.start - 1 );
		}
	};

	return TemplateLiteral;
}(Node));

var TryStatement = (function (Node$$1) {
	function TryStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) TryStatement.__proto__ = Node$$1;
	TryStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	TryStatement.prototype.constructor = TryStatement;

	TryStatement.prototype.minify = function minify ( code ) {
		if ( this.block.start > this.start + 3 ) { code.remove( this.start + 3, this.block.start ); }

		if ( this.handler ) {
			if ( this.handler.start > this.block.end ) {
				code.remove( this.block.end, this.handler.start );
			}

			if ( this.finalizer && this.finalizer.start > this.handler.end + 7 ) {
				code.overwrite( this.handler.end, this.finalizer.start, 'finally' );
			}
		} else {
			if ( this.finalizer.start > this.block.end + 7 ) {
				code.overwrite( this.block.end, this.finalizer.start, 'finally' );
			}
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return TryStatement;
}(Node));

var calculators$1 = {
	'!': function (x) { return !x; },
	'~': function (x) { return ~x; },
	'+': function (x) { return +x; },
	'-': function (x) { return -x; },
	'typeof': function (x)  { return typeof x; },
	'void'  : function (x)  { return void x; },
	'delete': function () { return UNKNOWN; }
};

var UnaryExpression = (function (Node$$1) {
	function UnaryExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) UnaryExpression.__proto__ = Node$$1;
	UnaryExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	UnaryExpression.prototype.constructor = UnaryExpression;

	UnaryExpression.prototype.getPrecedence = function getPrecedence () {
		return 15;
	};

	UnaryExpression.prototype.getValue = function getValue () {
		var arg = this.argument.getValue();

		if ( arg === UNKNOWN ) { return UNKNOWN; }

		if ( this.operator === '!' ) {
			if ( arg === TRUTHY ) { return false; }
			if ( arg === FALSY ) { return true; }
		}

		return calculators$1[ this.operator ]( arg );
	};

	UnaryExpression.prototype.minify = function minify ( code ) {
		var value = this.getValue();
		if ( value !== UNKNOWN && value !== TRUTHY && value !== FALSY ) {
			code.overwrite( this.start, this.end, stringify( value ) );
		}

		else {
			var len = this.operator.length;
			var start = this.start + len;

			var insertWhitespace = len > 1 && this.argument.getLeftHandSide().type !== 'ParenthesizedExpression';
			if ( insertWhitespace ) { code.appendLeft( start, ' ' ); }

			code.remove( start, this.argument.start );

			Node$$1.prototype.minify.call( this, code );
		}
	};

	return UnaryExpression;
}(Node));

var UpdateExpression = (function (Node$$1) {
	function UpdateExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) UpdateExpression.__proto__ = Node$$1;
	UpdateExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	UpdateExpression.prototype.constructor = UpdateExpression;

	UpdateExpression.prototype.getPrecedence = function getPrecedence () {
		return this.prefix ? 15 : 16;
	};

	UpdateExpression.prototype.initialise = function initialise () {
		if ( this.argument.type === 'Identifier' ) {
			var declaration = this.findScope( false ).findDeclaration( this.argument.name );
			if ( declaration && declaration.kind === 'const' ) {
				throw new CompileError( this, ((this.argument.name) + " is read-only") );
			}
		}

		Node$$1.prototype.initialise.call(this);
	};

	return UpdateExpression;
}(Node));

function extractNames ( node ) {
	var names = [];
	extractors[ node.type ]( names, node );
	return names;
}

var extractors = {
	Identifier: function Identifier ( names, node ) {
		names.push( node );
	},

	ObjectPattern: function ObjectPattern ( names, node ) {
		for ( var i = 0, list = node.properties; i < list.length; i += 1 ) {
			var prop = list[i];

			extractors[ prop.value.type ]( names, prop.value );
		}
	},

	ArrayPattern: function ArrayPattern ( names, node ) {
		for ( var i = 0, list = node.elements; i < list.length; i += 1 )  {
			var element = list[i];

			if ( element ) { extractors[ element.type ]( names, element ); }
		}
	},

	RestElement: function RestElement ( names, node ) {
		extractors[ node.argument.type ]( names, node.argument );
	},

	AssignmentPattern: function AssignmentPattern ( names, node ) {
		extractors[ node.left.type ]( names, node.left );
	}
};

var VariableDeclaration = (function (Node$$1) {
	function VariableDeclaration () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) VariableDeclaration.__proto__ = Node$$1;
	VariableDeclaration.prototype = Object.create( Node$$1 && Node$$1.prototype );
	VariableDeclaration.prototype.constructor = VariableDeclaration;

	VariableDeclaration.prototype.initialise = function initialise () {
		this.scope = this.findScope( this.kind === 'var' );
		this.skip = !!this.scope.parent; // TODO get rid of this

		this.declarations.forEach( function (declarator) { return declarator.initialise(); } );
	};

	VariableDeclaration.prototype.minify = function minify ( code ) {
		var declarations = this.declarations.filter( function (d) { return !d.skip; } );

		var allDupes = declarations.every( function (declarator) {
			return extractNames( declarator.id ).every( function (identifier) {
				return identifier.isDuplicate;
			});
		});

		var c = allDupes ? this.start : this.start + this.kind.length + ( this.declarations[0].id.type === 'Identifier' ? 1 : 0 );

		for ( var i = 0; i < declarations.length; i += 1 ) {
			var declarator = declarations[i];
			if ( declarator.skip ) { continue; }

			if ( declarator.start > c ) { code.overwrite( c, declarator.start, i ? ',' : '' ); }
			c = declarator.end;
		}

		if ( this.end > c + 1 ) { code.remove( c, this.end - 1 ); } // TODO semi-less declarations

		declarations.forEach( function (declarator) { return declarator.minify( code ); } );
	};

	return VariableDeclaration;
}(Node));

var VariableDeclarator = (function (Node$$1) {
	function VariableDeclarator () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) VariableDeclarator.__proto__ = Node$$1;
	VariableDeclarator.prototype = Object.create( Node$$1 && Node$$1.prototype );
	VariableDeclarator.prototype.constructor = VariableDeclarator;

	VariableDeclarator.prototype.activate = function activate () {
		this.skip = this.parent.skip = false;
		this.id.initialise();
		if ( this.init ) { this.init.initialise(); }
	};

	VariableDeclarator.prototype.initialise = function initialise () {
		var this$1 = this;

		var kind = this.parent.kind;
		this.scope = this.findScope( kind === 'var' );

		this.skip = this.parent.skip;

		extractNames( this.id ).forEach( function (node) {
			node.declaration = this$1;
			this$1.scope.addDeclaration( node, kind );
		});
	};

	VariableDeclarator.prototype.minify = function minify ( code ) {
		if ( this.init ) {
			if ( this.init.start > this.id.end + 1 ) { code.overwrite( this.id.end, this.init.start, '=' ); }
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return VariableDeclarator;
}(Node));

var WhileStatement = (function (Node$$1) {
	function WhileStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) WhileStatement.__proto__ = Node$$1;
	WhileStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	WhileStatement.prototype.constructor = WhileStatement;

	WhileStatement.prototype.getRightHandSide = function getRightHandSide () {
		return this.body.getRightHandSide();
	};

	WhileStatement.prototype.minify = function minify ( code ) {
		if ( this.test.start > this.start + 6 ) {
			code.overwrite( this.start + 5, this.test.start, '(' );
		}

		if ( this.body.start > this.test.end + 1 ) {
			code.overwrite( this.test.end, this.body.start, ')' );
		}

		// special case — empty body
		if ( this.body.body.length === 0 || this.body.body[0].type === 'EmptyStatement' ) {
			code.appendLeft( this.body.start, ';' );
			code.remove( this.body.start, this.body.end );
		}

		Node$$1.prototype.minify.call( this, code );
	};

	return WhileStatement;
}(Node));

var YieldExpression = (function (Node$$1) {
	function YieldExpression () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) YieldExpression.__proto__ = Node$$1;
	YieldExpression.prototype = Object.create( Node$$1 && Node$$1.prototype );
	YieldExpression.prototype.constructor = YieldExpression;

	YieldExpression.prototype.getPrecedence = function getPrecedence () {
		return 2;
	};

	return YieldExpression;
}(Node));

var types = {
	ArrayExpression: ArrayExpression,
	ArrayPattern: ArrayExpression,
	ArrowFunctionExpression: ArrowFunctionExpression,
	AssignmentExpression: AssignmentExpression,
	BinaryExpression: BinaryExpression,
	CallExpression: CallExpression,
	CatchClause: CatchClause,
	ClassBody: ClassBody,
	ClassDeclaration: ClassDeclaration,
	ClassExpression: ClassExpression,
	ConditionalExpression: ConditionalExpression,
	DoWhileStatement: DoWhileStatement,
	ExpressionStatement: ExpressionStatement,
	ForStatement: ForStatement,
	ForInStatement: ForInOfStatement,
	ForOfStatement: ForInOfStatement,
	FunctionDeclaration: FunctionDeclaration,
	FunctionExpression: FunctionExpression,
	Identifier: Identifier,
	IfStatement: IfStatement,
	ImportDefaultSpecifier: ImportDefaultSpecifier,
	ImportSpecifier: ImportSpecifier,
	Literal: Literal,
	LogicalExpression: LogicalExpression,
	MemberExpression: MemberExpression,
	MethodDefinition: MethodDefinition,
	NewExpression: NewExpression,
	ObjectExpression: ObjectExpression,
	ObjectPattern: ObjectPattern,
	ParenthesizedExpression: ParenthesizedExpression,
	ReturnStatement: ReturnStatement,
	SpreadElement: SpreadElement,
	SwitchCase: SwitchCase,
	SwitchStatement: SwitchStatement,
	TemplateLiteral: TemplateLiteral,
	TryStatement: TryStatement,
	UnaryExpression: UnaryExpression,
	UpdateExpression: UpdateExpression,
	VariableDeclaration: VariableDeclaration,
	VariableDeclarator: VariableDeclarator,
	WhileStatement: WhileStatement,
	YieldExpression: YieldExpression
};

function blockBreaksExecution ( body ) {
	var i = body.length;
	while ( i-- ) {
		var maybeReturnNode = breaksExecution( body[i] );
		if ( maybeReturnNode ) { return maybeReturnNode; }
	}

	return null;
}

function breaksExecution ( node ) {
	if ( node.type === 'ReturnStatement' || node.type === 'BreakStatement' || node.type === 'ContinueStatement' ) {
		return node;
	}

	if ( node.type === 'IfStatement' ) {
		var testValue = node.test.getValue();

		if ( testValue === UNKNOWN ) { return null; }

		if ( testValue ) { // if ( true ) {...}
			return blockBreaksExecution( node.consequent.body );
		}

		// if ( false ) {...}
		if ( !node.alternate ) { return null; }

		if ( node.alternate.type === 'BlockStatement' ) {
			return blockBreaksExecution( node.alternate.body );
		}

		if ( node.alternate.type === 'IfStatement' ) {
			return breaksExecution( node.alternate );
		}

		return null;
	}
}

function compatibleDeclarations ( a, b ) {
	if ( a === b ) { return true; }
	if ( a === 'var' || b === 'var' ) { return false; }
	return true;
}

var shouldPreserveAfterReturn = {
	FunctionDeclaration: true,
	VariableDeclaration: true,
	ClassDeclaration: true
};

var allowsBlockLessStatement = {
	ForStatement: true,
	ForInStatement: true,
	ForOfStatement: true,
	IfStatement: true,
	WhileStatement: true
};

function endsWithCurlyBrace ( statement ) {
	if ( statement.type === 'IfStatement' ) {
		if ( statement.rewriteAsSequence ) { return false; }

		if ( statement.alternate ) {
			if ( statement.alternate.type === 'IfStatement' ) {
				return endsWithCurlyBrace( statement.alternate );
			}

			if ( statement.alternate.synthetic ) { return false; }
			if ( statement.alternate.removeCurlies ) { return false; }

			return true;
		}

		return !statement.consequent.synthetic && !statement.consequent.removeCurlies;
	}

	if ( /^(?:For(?:In|Of)?|While)Statement/.test( statement.type ) ) {
		return !statement.body.synthetic && !statement.body.removeCurlies;
	}

	return /(?:Class|Function)Declaration/.test( statement.type );
}

var BlockStatement = (function (Node$$1) {
	function BlockStatement () {
		Node$$1.apply(this, arguments);
	}

	if ( Node$$1 ) BlockStatement.__proto__ = Node$$1;
	BlockStatement.prototype = Object.create( Node$$1 && Node$$1.prototype );
	BlockStatement.prototype.constructor = BlockStatement;

	BlockStatement.prototype.createScope = function createScope ( parent ) {
		var this$1 = this;

		this.parentIsFunction = /Function/.test( this.parent.type );
		this.isFunctionBlock = this.parentIsFunction || this.parent.type === 'Root';

		this.scope = new Scope({
			block: !this.isFunctionBlock,
			parent: parent || this.parent.findScope( false ), // TODO always supply parent
			owner: this
		});

		var params = this.parent.params || ( this.parent.type === 'CatchClause' && [ this.parent.param ] );

		if ( params && params.length ) {
			params.forEach( function (node) {
				extractNames( node ).forEach( function (identifier) {
					this$1.scope.addDeclaration( identifier, 'param' );
				});
			});
		}
	};

	BlockStatement.prototype.initialise = function initialise () {
		var this$1 = this;

		// normally the scope gets created here, during initialisation,
		// but in some cases (e.g. `for` statements), we need to create
		// the scope early, as it pertains to both the init block and
		// the body of the statement
		if ( !this.scope ) { this.createScope( this.parent.findScope( false ) ); }

		var executionIsBroken = false;
		var maybeReturnNode;
		var hasDeclarationsAfterBreak = false;

		var canCollapseReturns = this.parentIsFunction;
		var returnStatements = [];

		for ( var i = 0; i < this.body.length; i += 1 ) {
			var node = this$1.body[i];

			if ( executionIsBroken ) {
				if ( shouldPreserveAfterReturn[ node.type ] ) {
					hasDeclarationsAfterBreak = true;
					node.initialise();
				} else {
					node.skip = true;
				}

				continue;
			}

			maybeReturnNode = breaksExecution( node );
			if ( maybeReturnNode ) { executionIsBroken = true; }

			node.initialise();

			if ( canCollapseReturns ) {
				if ( node.preventsCollapsedReturns( returnStatements ) ) {
					canCollapseReturns = false;
				} else {
					// console.log( `${node.type} preventsCollapsedReturns`)
				}
			}
		}

		this.collapseReturnStatements = canCollapseReturns && returnStatements.length;
		this.returnStatements = returnStatements;

		// if `return` is the last line of a function, remove it
		if ( maybeReturnNode && this.parentIsFunction && !hasDeclarationsAfterBreak ) {
			// TODO also capture `return undefined` and `return void 0` etc?
			if ( !maybeReturnNode.argument ) {
				maybeReturnNode.skip = true;
			}
		}

		this.scope.consolidate();
	};

	BlockStatement.prototype.findVarDeclarations = function findVarDeclarations ( varsToHoist ) {
		if ( !this.scope ) { this.createScope( this.parent.findScope( false ) ); }

		this.body.forEach( function (node) {
			if ( node.type === 'VariableDeclaration' && node.kind === 'var' ) {
				node.declarations.forEach( function (declarator) {
					extractNames( declarator.id ).forEach( function (identifier) {
						varsToHoist[ identifier.name ] = true;
					});
				});
			} else {
				node.findVarDeclarations( varsToHoist );
			}
		});

		this.scope.consolidate();
	};

	BlockStatement.prototype.findLexicalBoundary = function findLexicalBoundary () {
		if ( this.type === 'Program' ) { return this; }
		if ( /^Function/.test( this.parent.type ) ) { return this; }

		return this.parent.findLexicalBoundary();
	};

	BlockStatement.prototype.findScope = function findScope ( functionScope ) {
		if ( functionScope && !this.isFunctionBlock ) { return this.parent.findScope( functionScope ); }
		return this.scope;
	};

	BlockStatement.prototype.getLeftHandSide = function getLeftHandSide () {
		if ( this.removeCurlies || this.synthetic ) { return this.body[0].getLeftHandSide(); }
		return this;
	};

	BlockStatement.prototype.getRightHandSide = function getRightHandSide () {
		if ( this.removeCurlies || this.synthetic ) { return this.body[this.body.length - 1].getRightHandSide(); }
		return this;
	};

	BlockStatement.prototype.minify = function minify ( code ) {
		if ( this.scope ) { this.scope.mangle( code ); } // class declarations do not create their own scope

		var statements = this.body.filter( function (statement) { return !statement.skip; } );

		// if ( this.collapseReturnStatements ) {
		// 	this.minifyWithCollapsedReturnStatements( code, statements );
		// } else {
		statements.forEach( function (statement) {
			statement.minify( code );
		});
		// }

		// TODO this is confusing
		var rewriteAsSequence = !this.parentIsFunction && statements.length > 0 && ( this.joinStatements || statements.every( function (statement) {
			return statement.type === 'ExpressionStatement' ||
			       statement.rewriteAsSequence;
		}) );

		var separator = rewriteAsSequence ? ',' : ';';

		// TODO this is confusing
		var removeCurlies = this.parent.type === 'Root' || !this.synthetic && (
			this.parent.type === 'IfStatement' ?
				this.removeCurlies :
				( allowsBlockLessStatement[ this.parent.type ] && rewriteAsSequence )
		);

		this.removeCurlies = removeCurlies;

		// remove leading whitespace
		var lastEnd = ( this.parent.type === 'Root' || removeCurlies ) ? this.start : this.start + 1;

		if ( statements.length ) {
			var nextSeparator = '';

			for ( var i = 0; i < statements.length; i += 1 ) {
				var statement = statements[i];

				if ( nextSeparator === '' ) {
					if ( statement.start > lastEnd ) { code.remove( lastEnd, statement.start ); }
				} else {
					if ( statement.start === lastEnd ) {
						code.appendLeft( lastEnd, separator );
					} else {
						if ( code.original.slice( lastEnd, statement.start ) !== nextSeparator ) {
							code.overwrite( lastEnd, statement.start, nextSeparator );
						}
					}
				}

				lastEnd = statement.end;

				// remove superfluous semis
				while ( code.original[ lastEnd - 1 ] === ';' ) { lastEnd -= 1; }

				if ( statement.removed ) {
					nextSeparator = '';
				}

				else {
					nextSeparator = endsWithCurlyBrace( statement ) ? '' : separator;
				}
			}

			var end = removeCurlies ? this.end : this.end - 1;
			if ( end > lastEnd ) { code.remove( lastEnd, end ); }
		} else {
			// empty block
			if ( this.removeCurlies || this.parent.type === 'Root' ) {
				code.remove( this.start, this.end );
			} else if ( this.end > this.start + 2 ) {
				code.remove( this.start + 1, this.end - 1 );
			}
		}

		// combine adjacent var declarations
		var lastStatement;
		for ( var i$1 = 0, list = statements; i$1 < list.length; i$1 += 1 ) {
			var statement$1 = list[i$1];

			if ( lastStatement && lastStatement.type === 'VariableDeclaration' && statement$1.type === 'VariableDeclaration' ) {
				// are they compatible?
				if ( compatibleDeclarations( lastStatement.kind, statement$1.kind ) ) {
					var lastDeclarator = lastStatement.declarations[ lastStatement.declarations.length - 1 ];
					code.overwrite( lastDeclarator.end, statement$1.declarations[0].start, ',' );

					statement$1.collapsed = true;
				}
			}

			if ( !statement$1.collapsed && statement$1.kind === 'const' && ( !lastStatement || lastStatement.kind !== 'VariableDeclaration' ) ) {
				code.overwrite( statement$1.start, statement$1.start + 5, 'let' );
			}

			lastStatement = statement$1;
		}
	};

	return BlockStatement;
}(Node));

var statementsWithBlocks = {
	ForStatement: 'body',
	ForInStatement: 'body',
	ForOfStatement: 'body',
	WhileStatement: 'body',
	DoWhileStatement: 'body',
	ArrowFunctionExpression: 'body'
};

function synthetic ( expression ) {
	return {
		start: expression.start,
		end: expression.end,
		type: 'BlockStatement',
		body: [ expression ],
		synthetic: true
	};
}

function wrap ( raw, parent ) {
	if ( !raw ) { return; }

	if ( 'length' in raw ) {
		var i = raw.length;
		while ( i-- ) { wrap( raw[i], parent ); }
		return;
	}

	// with e.g. shorthand properties, key and value are
	// the same node. We don't want to wrap an object twice
	if ( raw.__wrapped ) { return; }
	raw.__wrapped = true;

	if ( !keys[ raw.type ] ) {
		keys[ raw.type ] = Object.keys( raw ).filter( function (key) { return typeof raw[ key ] === 'object'; } );
	}

	// create synthetic block statements, otherwise all hell
	// breaks loose when it comes to block scoping
	if ( raw.type === 'IfStatement' ) {
		if ( raw.consequent.type !== 'BlockStatement' ) { raw.consequent = synthetic( raw.consequent ); }
		if ( raw.alternate && raw.alternate.type !== 'BlockStatement' ) { raw.alternate = synthetic( raw.alternate ); }
	} else if ( statementsWithBlocks[ raw.type ] && raw.body.type !== 'BlockStatement' ) {
		raw.body = synthetic( raw.body );
	}

	Node( raw, parent );

	var type = ( raw.type === 'BlockStatement' ? BlockStatement : types[ raw.type ] ) || Node;
	raw.__proto__ = type.prototype;
}

function check ( magicString, ast ) {
	var code = magicString.toString();

	try {
		parse( code, {
			ecmaVersion: 8,
			sourceType: 'module'
		});
	} catch ( err ) {
		var map = magicString.generateMap();
		var ref = err.loc;
		var line = ref.line;
		var column = ref.column;
		var snippet = code.slice( Math.max( 0, err.pos - 35 ), Math.min( code.length, err.pos + 35 ) );

		var mappings = decode( map.mappings );
		var segments = mappings[ line - 1 ];

		for ( var i = 0; i < segments.length; i += 1 ) {
			var segment = segments[i];
			if ( segment[0] >= column ) {
				var sourceCodeLine = segment[2];
				var sourceCodeColumn = segment[3];

				err.message = "Butternut generated invalid JS: code in source file near (" + (sourceCodeLine + 1) + ":" + sourceCodeColumn + ") became\n..." + snippet + "...";

				try {
					var repro = createRepro( magicString.original, ast, sourceCodeLine, sourceCodeColumn );
					if ( repro ) { err.repro = repro; }
				} catch (err) {
					// do nothing
				}

				throw err;
			}
		}

		throw err;
	}
}

function createRepro ( source, ast, line, column ) {
	var lines = source.split( '\n' );

	var c = 0;
	for ( var i = 0; i < line; i += 1 ) { c += lines[i].length + 1; }
	c += column;

	var node = zoomIn( ast, c );

	do {
		node = zoomOut( node );

		var slice = source.slice( node.start, node.end );
		var ast$1 = parse( slice, {
			ecmaVersion: 8,
			preserveParens: true,
			sourceType: 'module',
			allowReturnOutsideFunction: true
		});

		var ref = new Program( slice, ast$1, null ).export({});
		var code = ref.code;

		try {
			parse( code, {
				ecmaVersion: 8,
				sourceType: 'module',
				allowReturnOutsideFunction: true
			});
		} catch ( err ) {
			return {
				input: slice,
				output: code
			};
		}
	} while ( node );
}

function zoomIn ( node, c ) {
	if ( !node ) { return null; }

	if ( c < node.start ) { return null; }
	if ( c > node.end ) { return null; }

	var k = keys[ node.type ];
	for ( var i = 0; i < k.length; i += 1 ) {
		var key = k[i];

		if ( Array.isArray( node[key] ) ) {
			var body = node[key];

			for ( var j = 0; j < body.length; j += 1 ) {
				if ( body[j] ) {
					if ( body[j].start > c ) { return zoomIn( body[j], body[j].start ); }

					var child = zoomIn( body[j], c );
					if ( child ) { return child; }
				}
			}
		} else {
			var child$1 = zoomIn( node[key], c );
			if ( child$1 ) { return child$1; }
		}
	}

	return node;
}

function zoomOut ( node ) {
	while ( !/Statement|Declaration/.test( node.parent.type ) ) {
		if ( !node.parent ) { return null; }
		node = node.parent;
	}

	return node.parent;
}

function Program ( source, ast, stats ) {
	this.stats = stats;
	this.type = 'Root';

	this.source = source;
	this.magicString = new MagicString( source );
	this.ast = ast;
	this.depth = 0;

	wrap( this.body = ast, this );
	this.body.__proto__ = BlockStatement.prototype;
	this.templateElements = [];
	this.body.initialise();
	this.body.minify( this.magicString );
	
}

Program.prototype = {
	export: function export$1 ( options ) {
		var this$1 = this;

		var stats = this.stats;

		var code = this.magicString.toString();
		if ( options.check ) {
			check( this.magicString, this.ast );
		}

		var map = options.sourceMap !== false ? this.magicString.generateMap({
			file: options.file,
			source: options.source,
			includeContent: options.includeContent !== false
		}) : null;
		if ( false && this.magicString.stats ) {
			Object.keys( this.magicString.stats ).forEach( function (stat) {
				stats[ stat ] = this$1.magicString.stats[ stat ];
			});
		}

		return { code: code, map: map, stats: stats };
	},

	findNearest: function findNearest () {
		return null;
	},

	findScope: function findScope () {
		return this.body.scope;
	}
};

var Stats = function Stats () {
	Object.defineProperties( this, {
		startTimes: { value: {} }
	});
};

Stats.prototype.time = function time ( label ) {
	this.startTimes[ label ] = process.hrtime();
};

Stats.prototype.timeEnd = function timeEnd ( label ) {
	var elapsed = process.hrtime( this.startTimes[ label ] );

	if ( !this[ label ] ) { this[ label ] = 0; }
	this[ label ] += elapsed[0] * 1e3 + elapsed[1] * 1e-6;
};

var version = "0.3.6";

function squash ( source, options ) {
	if ( options === void 0 ) options = {};

	var ast;

	var stats = null;

	try {
		ast = parse( source, {
			ecmaVersion: 8,
			preserveParens: true,
			sourceType: 'module'
		});
		
	} catch ( err ) {
		err.snippet = getSnippet( source, err.loc );
		throw err;
	}

	return new Program( source, ast, stats ).export( options );
}

export { squash, version as VERSION };
//# sourceMappingURL=butternut.es.js.map
